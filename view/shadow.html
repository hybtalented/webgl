<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Show Example</title>
    <script type="text/javascript" src="../js/cuon-matrix.js"></script>
    <script type="text/javascript" src="../js/util.js"></script>
    <script type="text/javascript" src="../js/dem_with_texture.js"></script>
</head>

<body>

    <canvas id="canvas" width="1920" height="1080"></canvas>
    <script type="text/javascript">
        let animation;
        window.onload = async function () {
            /**
             * @type {HTMLCanvasElement}
             */
            var canvas = document.getElementById('canvas');
            var gl = canvas.getContext('webgl');
            gl.cullFace(gl.BACK);
            gl.enable(gl.DEPTH_TEST)
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            var frameVShaderSource =
                "attribute vec4 a_Position;" +
                "uniform mat4 u_mvpMatrix;" +
                "void main() {" +
                "gl_Position = u_mvpMatrix * a_Position;" +
                "}";
            var frameFShaderSource =
                "precision mediump float;" +
                "void main() {" +
                "const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);" +
                "const vec4 bitMask = vec4(1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0, 0.0);" +
                "vec4 rgbaDepth = fract(gl_FragCoord.z * bitShift);" +
                "gl_FragColor = rgbaDepth - rgbaDepth.gbaa * bitMask;" +
                "}";
            var vShaderSource =
                "attribute vec4 a_Position;" +
                "attribute vec4 a_Normal;" +
                "attribute vec2 a_texCoord;" +
                "uniform mat4 u_mvpMatrixFromLight;" +
                "uniform mat4 u_mvpMatrix;" +
                "varying vec4 v_positionFromLight;" +
                "varying vec4 v_Normal;" +
                "varying vec2 v_texCoord;" +
                "void main() {" +
                "gl_Position = u_mvpMatrix * a_Position;" +
                "v_positionFromLight = u_mvpMatrixFromLight * a_Position;" +
                "v_Normal = a_Normal;" +
                "v_texCoord = a_texCoord;" +
                "}";
            var fShaderSource =
                'precision mediump float;' +
                // 阴影贴图
                "uniform sampler2D u_samplerDepth;" +
                // 地形贴图
                "uniform sampler2D u_samplerGeo;" +
                // 平行光的方向
                "uniform vec3 u_lightDirection;" +
                // 平行光的颜色
                "uniform vec3 u_diffUseLight;" +
                // 环境光颜色
                "uniform vec3 u_ambientLight;" +
                "varying vec4 v_positionFromLight;" +
                "varying vec4 v_Normal;" +
                "varying vec2 v_texCoord;" +
                'float unpackDepth(const in vec4 rgbaDepth) {' +
                'const vec4 bitShift = vec4(1.0, 1.0 / 255.0, 1.0 / ( 255.0 * 255.0 ), 1.0 / ( 255.0 * 255.0 * 255.0 ));' +
                'float depth = dot(rgbaDepth, bitShift);' +
                'return depth;' +
                '}' +
                "void main() {" +
                "vec3 shadowCoord = ( v_positionFromLight.xyz / v_positionFromLight.w ) / 2.0 + 0.5;" +
                "vec4 rgbaDepth = texture2D(u_samplerDepth, shadowCoord.xy);" +
                "vec4 geoTexture = texture2D(u_samplerGeo, v_texCoord);" +
                'float depth = unpackDepth(rgbaDepth);' +
                'float visibility = (shadowCoord.z > depth + 0.0015) ? 0.7 : 1.0;' +
                'vec3 normal = normalize(v_Normal.xyz);' +
                'float nDotL = max(dot(normal, u_lightDirection), 0.0);' +
                'vec3 diffUse = u_diffUseLight * geoTexture.rgb * nDotL;' +
                'vec3 ambient = u_ambientLight * geoTexture.rgb;' +
                'gl_FragColor = vec4((diffUse + ambient) * visibility, geoTexture.a);' +
                "}";

            const frameProgram = new WebGLProgramWrapper(gl);
            const drawProgram = new WebGLProgramWrapper(gl);
            frameProgram.init(frameVShaderSource, frameFShaderSource);
            drawProgram.init(vShaderSource, fShaderSource);
            var dem = new DEMLoader();

            const isValid = dem.loadDEM(dem_string);
            if (!isValid) {
                console.error('dem_string should be a valid dem');
                return;
            }

            initFrameBuffer();
            // 初始化缓冲区数据
            initBufferData();

            if (!animation) {
                animation = new BasicAnimation(gl, canvas);
            }

            function initFrameBuffer() {
                const frameBuffer = new WebGLFrameBufferWrapper(gl, 400, 400);
                framebuffer.bind();
                // 将帧缓冲区颜色关联对象板顶的纹理1
                const depthTexture = new WebGLTextureWrapper(gl, gl.RGBA);

                depthTexture.bind(1);
                depthTexture.setParams();
                depthTexture.bindFramebuffer(framebuffer, gl.COLOR_ATTACHMENT0);

                framebuffer.unbind();
            }

            function initBufferData() {
                const vertices = await dem.loadTexture(gl, dem_texture_image, {
                    id: 0,
                    with_normal: true
                })

                const vertexBuffer = new WebGLBufferWrapper(gl, gl.ARRAY_BUFFER);
                vertexBuffer.bind();
                vertexBuffer.init(gl.STATIC_DRAW, new Float32Array(vertices.flat()), 8);


                const indiceData = new Uint16Array(trangles.flat());
                const elementsBuffer = new WebGLBufferWrapper(gl, gl.ELEMENT_ARRAY_BUFFER);
                elementsBuffer.bind();
                elementsBuffer.init(gl.STATIC_DRAW, new Uint16Array(indiceData));


                drawProgram.use();

                // 绑定纹理
                gl.uniform1i(drawProgram.u_samplerGeo, 0);
                gl.uniformli(drawProgram.u_samplerDepth, 1);
                vertexBuffer.bindAttibute(drawProgram.a_Position, 3, gl.FLOAT);
                vertexBuffer.bindAttibute(drawProgram.a_Normal, 3, gl.FLOAT, 3);
                vertexBuffer.bindAttibute(drawProgram.a_texCoord, 2, gl.FLOAT, 6);

                const {
                    trangles
                } = dem;

                frameProgram.use();
                vertexBuffer.bindAttibute(drawProgram.a_Position, 3, gl.FLOAT);

                elementsBuffer.unbind();
                vertexBuffer.unbind();
            }
        }
    </script>
</body>

</html>